<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacestub" kind="namespace" language="C++">
    <compoundname>stub</compoundname>
    <innerclass refid="structstub_1_1compare" prot="public">stub::compare</innerclass>
    <innerclass refid="structstub_1_1compare__call" prot="public">stub::compare_call</innerclass>
    <innerclass refid="classstub_1_1function" prot="public">stub::function</innerclass>
    <innerclass refid="classstub_1_1function_3_01_r_07_args_8_8_8_08_4" prot="public">stub::function&lt; R(Args...)&gt;</innerclass>
    <innerclass refid="structstub_1_1ignore" prot="public">stub::ignore</innerclass>
    <innerclass refid="structstub_1_1not__nullptr" prot="public">stub::not_nullptr</innerclass>
    <innerclass refid="classstub_1_1return__handler" prot="public">stub::return_handler</innerclass>
    <innerclass refid="classstub_1_1return__handler_3_01void_01_4" prot="public">stub::return_handler&lt; void &gt;</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="arguments_8hpp_1aacd798322a3338da4b2fcfbe81c9065b" prot="public" static="no">
        <type>decltype(std::make_tuple(std::declval&lt; Args &gt;()...))</type>
        <definition>using stub::arguments = typedef decltype(std::make_tuple(std::declval&lt;Args&gt;()...))</definition>
        <argsstring></argsstring>
        <name>arguments</name>
        <briefdescription>
<para>Tuple containing the values actually passed in the call. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/arguments.hpp" line="14" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/arguments.hpp" bodystart="14" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="unqualified__type_8hpp_1a5b28cb629ea8f092b003162ff9dbf837" prot="public" static="no">
        <type>std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;</type>
        <definition>using stub::unqualified_type = typedef std::remove_cv&lt; typename std::remove_reference&lt;T&gt;::type&gt;</definition>
        <argsstring></argsstring>
        <name>unqualified_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the unqualified type, i.e.</para><para>using v = typename unqualified_type&lt;const uint32_t&amp;&gt;::type;</para><para>Then v is uint32_t</para><para>More info here: <ulink url="http://stackoverflow.com/questions/17295169">http://stackoverflow.com/questions/17295169</ulink> <ulink url="http://flamingdangerzone.com/cxx11/2013/02/25/even-more-traits.html">http://flamingdangerzone.com/cxx11/2013/02/25/even-more-traits.html</ulink> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/unqualified_type.hpp" line="25" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/unqualified_type.hpp" bodystart="27" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="compare__argument_8hpp_1a8ed204e601e3f9ee9f58c30efd439a9c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class U</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool stub::compare_argument</definition>
        <argsstring>(T a, U b)</argsstring>
        <name>compare_argument</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <param>
          <type>U</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Compares two arguments of same type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" line="19" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" bodystart="19" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="compare__argument_8hpp_1a8478ab626a8f84f25f42781e6fdad717" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool stub::compare_argument</definition>
        <argsstring>(T a, ignore)</argsstring>
        <name>compare_argument</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structstub_1_1ignore" kindref="compound">ignore</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compare function where the second argument is ignore - this always compares true </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" line="27" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" bodystart="27" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="compare__argument_8hpp_1ad1d1ff4bb1d54cb91c99c7c7adcccc88" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool stub::compare_argument</definition>
        <argsstring>(T a, not_nullptr)</argsstring>
        <name>compare_argument</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structstub_1_1not__nullptr" kindref="compound">not_nullptr</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compare function where the second argument is <ref refid="structstub_1_1not__nullptr" kindref="compound">not_nullptr</ref> - this evaluates to true if the first argument is anything but nullptr </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" line="36" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" bodystart="36" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="compare__argument_8hpp_1a3a0a757e0ed47a0b6f1cd5c8288fd7cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
          <param>
            <type>class Compare</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool stub::compare_argument</definition>
        <argsstring>(T a, compare&lt; Compare &gt; t)</argsstring>
        <name>compare_argument</name>
        <param>
          <type>T</type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structstub_1_1compare" kindref="compound">compare</ref>&lt; Compare &gt;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Compare argument using custom comparison functor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" line="47" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_argument.hpp" bodystart="47" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="compare__arguments_8hpp_1a4e316d1ea86d2002ca7ab51957433e7d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Index</type>
            <defval>std::integral_constant&lt;uint32_t, 0U&gt;</defval>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>WithArgs</declname>
            <defname>WithArgs</defname>
          </param>
          <param>
            <type>class LastIndex</type>
            <defval>std::integral_constant&lt;uint32_t, sizeof...(Args)&gt;</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; std::is_same&lt; Index, LastIndex &gt;::value, uint8_t &gt;::type</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool stub::compare_arguments</definition>
        <argsstring>(const std::tuple&lt; Args... &gt; &amp;actual, const std::tuple&lt; WithArgs... &gt; &amp;with)</argsstring>
        <name>compare_arguments</name>
        <param>
          <type>const std::tuple&lt; Args... &gt; &amp;</type>
          <declname>actual</declname>
        </param>
        <param>
          <type>const std::tuple&lt; WithArgs... &gt; &amp;</type>
          <declname>with</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Specialization chosen for empty tuples or when Index reaches the sizeof the tuple (i.e. the number of values in the tuple), see description below.</para><para><simplesect kind="return"><para>When the two tuples are empty they compare equal so we return true</para></simplesect>
Compare the content of two tuples.</para><para>The two functions compare_arguments use SFINAE (Substitution Failure Is Not An Error) to select which overload to call.</para><para>The overloading works like this:</para><para><orderedlist>
<listitem><para>If compare_arguments is called with an empty tuple then the empty overload will be chosen.</para></listitem><listitem><para>If compare_arguments is called with a non-empty tuple the Index!=LastIndex is true and the overload calling compare_arugment(...) will be called. This will then recursively call compare_arguments incrementing the Index. A some point Index==LastIndex and the empty overload gets chosen and we are done.</para></listitem></orderedlist>
</para><para>Note that initially this was implemented using a simpler technique similar to here: <ulink url="http://stackoverflow.com/a/6894436">http://stackoverflow.com/a/6894436</ulink> but this did not work on with Microsoft Visual Studio 2013 so it was implemented using the std::integral_constant technique instead. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_arguments.hpp" line="31" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/compare_arguments.hpp" bodystart="31" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="function_8hpp_1a0a560b70c78ab118c187a233bc3f141f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; stub::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const function&lt; T &gt; &amp;function)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="classstub_1_1function" kindref="compound">function</ref>&lt; T &gt; &amp;</type>
          <declname>function</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Output operator for printing function objects, see more info in stub::function::print(std::ostream&amp;).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>The output stream where the state of the function object will be printed.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>function</parametername>
</parameternamelist>
<parameterdescription>
<para>The function object we want to print</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The ostream operator. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/function.hpp" line="270" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/function.hpp" bodystart="270" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="make__compare_8hpp_1affe5a2c7ea37fa129c2d255575b203a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class C</type>
          </param>
        </templateparamlist>
        <type><ref refid="structstub_1_1compare" kindref="compound">compare</ref>&lt; C &gt;</type>
        <definition>compare&lt;C&gt; stub::make_compare</definition>
        <argsstring>(C c)</argsstring>
        <name>make_compare</name>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Small helper function for creating compare objects.</para><para>Example:</para><para>// Build a comparison function from a lambda auto compare = stub::make_compare([](uint32_t v)-&gt;bool { return v == 1U}; );</para><para>assert(compare(1U) == true); assert(compare(2U) == false); </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/make_compare.hpp" line="23" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/make_compare.hpp" bodystart="23" bodyend="26"/>
      </memberdef>
      <memberdef kind="function" id="print__argument_8hpp_1a58ba4b943e729387129fb4e37387a5e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void stub::print_argument</definition>
        <argsstring>(std::ostream &amp;out, uint32_t index, T value)</argsstring>
        <name>print_argument</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default printer - just use the std::ostream operator&lt;&lt; to output the values to the stream. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/print_argument.hpp" line="17" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/print_argument.hpp" bodystart="17" bodyend="20"/>
      </memberdef>
      <memberdef kind="function" id="print__argument_8hpp_1a229bfdcff8f78a349bf48025b21a1f67" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void stub::print_argument</definition>
        <argsstring>(std::ostream &amp;out, uint32_t index, T *value)</argsstring>
        <name>print_argument</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>index</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Overload of the default printer function for pointer types.</para><para>The reason we overload for pointers is that we cannot rely on the default std::ostream operator&lt;&lt; for printing pointers. std::ostream operator&lt;&lt; is overloaded for e.g. char* (and on most platforms also uint8_t*) to try to print it as a zero-terminated string.</para><para>However, in many applications dealing with binary data i.e. uint8_t pointers are not to strings but to actual binary data. In these cases trying to print the data as a zero-terminated string leads to all sorts of out-of-bounds memory access. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/print_argument.hpp" line="34" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/print_argument.hpp" bodystart="34" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="print__arguments_8hpp_1aaf37c5066d37a7218eaa988aab8b1a06" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Index</type>
            <defval>std::integral_constant&lt;uint32_t, 0U&gt;</defval>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>class LastIndex</type>
            <defval>std::integral_constant&lt;uint32_t, sizeof...(Args)&gt;</defval>
          </param>
          <param>
            <type>typename std::enable_if&lt; std::is_same&lt; Index, LastIndex &gt;::value, uint8_t &gt;::type</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void stub::print_arguments</definition>
        <argsstring>(std::ostream &amp;out, const std::tuple&lt; Args... &gt; &amp;t)</argsstring>
        <name>print_arguments</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const std::tuple&lt; Args... &gt; &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Specialization chosen for empty tuples or when Index reaches the sizeof the tuple (i.e. the number of values in the tuple), see description below.</para><para>Prints the content of a tuple to the specified std::ostream.</para><para>The two functions print_arguments use SFINAE (Substitution Failure Is Not An Error) to select which overload to call.</para><para>The overloading works like this:</para><para><orderedlist>
<listitem><para>If print_arguments is called with an empty tuple then the empty overload will be chosen.</para></listitem><listitem><para>If print_argument is called with a non-empty tuple the Index!=LastIndex is true and the overload writing to the std::ostream will be called. This will then recursively call print_arguments incrementing the Index. A some point Index==LastIndex and the empty overload gets chosen and we are done.</para></listitem></orderedlist>
</para><para>Note that initially this was implemented using a simpler technique similar to here: <ulink url="http://stackoverflow.com/a/6894436">http://stackoverflow.com/a/6894436</ulink> but this did not work on with Microsoft Visual Studio 2013 so it was implemented using the std::integral_constant technique instead. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/print_arguments.hpp" line="26" column="1" bodyfile="/tmp/giit/data/clones/stub-5d6b38/src/stub/print_arguments.hpp" bodystart="26" bodyend="30"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/tmp/giit/data/clones/stub-5d6b38/src/stub/arguments.hpp" line="11" column="1"/>
  </compounddef>
</doxygen>
