{"stub::compare::operator()(Value)": {"type": "function", "scope": "stub::compare", "name": "operator()", "return": {"type": "bool", "description": [], "link": null}, "signature": "operator()(Value v)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Call operator which calls the compare function with the passed value."}], "detaileddescription": [], "parameters": [{"type": "Value", "link": null, "name": "v", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare": {"type": "struct", "name": "compare", "location": {"file": "stub/compare.hpp", "line-start": 26, "line-stop": 37}, "scope": "stub", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "An object used to customize comparison of specific arguments when comparing two function calls."}, {"type": "text", "content": "Example:"}, {"type": "text", "content": "bool test(uint32_t v) { return v == 1U; }"}, {"type": "text", "content": "stub::compare<bool(*)(uint32_t)> compare = { test };"}, {"type": "text", "content": "assert(compare(1U) == true); assert(compare(2U) == false);"}], "members": ["stub::compare::operator()(Value)"], "access": "public"}, "stub::compare_call::compare_call(WithArgs&&...)": {"type": "function", "scope": "stub::compare_call", "name": "compare_call", "return": {"type": "", "description": [], "link": null}, "signature": "compare_call(WithArgs &&... expected)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Construct a new call comparison."}], "detaileddescription": [], "parameters": [{"type": "WithArgs &&...", "link": null, "name": "expected", "description": ""}], "is_constructor": true, "is_destructor": false}, "stub::compare_call::compare(constarguments<Args...>&)const": {"type": "function", "scope": "stub::compare_call", "name": "compare", "return": {"type": "bool", "description": [{"type": "text", "content": "Compare the values of the passed tuple with those of the expectation."}], "link": null}, "signature": "compare(const arguments< Args... > &actual) const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "const arguments< Args... > &", "link": null, "name": "actual", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_call": {"type": "struct", "name": "compare_call", "location": {"file": "stub/compare_call.hpp", "line-start": 63, "line-stop": 115}, "scope": "stub", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "This stores a tuple of types that is to, at some point, be compared with a different tuple of arguments."}, {"type": "text", "content": "The basic usage is as follows:"}, {"type": "text", "content": "auto expectation = std::make_tuple(5, true, 4.0); compare_call<int, bool, double> expect(expectation);"}, {"type": "text", "content": "auto actual = std::make_tuple(4, true, 4.0);"}, {"type": "text", "content": "// Now compare our expectation with the actual values bool result = expect.compare(actual); assert(result == false);"}, {"type": "text", "content": "The"}, {"type": "text", "content": "compare_call::compare", "link": "stub::compare_call::compare(constarguments<Args...>&)const"}, {"type": "text", "content": "(...) function uses compare_arguments(...) to compare the elements of the two tuples element-wise using compare_argument(...). In the case above the two tuples contain the same types. So every thing is pretty straight-forward."}, {"type": "text", "content": "However, in some cases we want to customize the comparison of two element. This could be that we simply don't care about a specific value or we want to use a user-define comparison function."}, {"type": "text", "content": "To support this use-case we allow special values to be used in the comparison tuple. The two tuples can therefore have different types, making the implementation a bit more involved and the reason for the type-erausre implemented in this class."}, {"type": "text", "content": "Lets see how this would work in practice."}, {"type": "text", "content": "// Notice how we can pass ignore() as the second argument to our // expectation tuple. auto expectation = std::make_tuple(5, ignore(), 4.0); compare_call<int, bool, double> expect(expectation);"}, {"type": "text", "content": "auto actual = std::make_tuple(5, true, 4.0);"}, {"type": "text", "content": "// Now compare our expectation with the actual values bool result = expect.compare(actual); assert(result == true);"}, {"type": "text", "content": "The reason this works when comparing the two tuples element-wise is that the compare_argument(...) function has an overload that accepts ignore as the second argument. By specializing compare_argument(...) we can extend support for more special values to support custom behaviour."}], "members": ["stub::compare_call::compare(constarguments<Args...>&)const", "stub::compare_call::compare_call(WithArgs&&...)", "stub::compare_call::implementation", "stub::compare_call::interface"], "access": "public"}, "stub::function<R(Args...)>::expectation::expectation(constfunction&)": {"type": "function", "scope": "stub::function< R(Args...)>::expectation", "name": "expectation", "return": {"type": "", "description": [], "link": null}, "signature": "expectation(const function &the_function)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "const function &", "link": "stub::function", "name": "the_function", "description": [{"type": "text", "content": "The function we configuring an expectation for"}]}], "is_constructor": true, "is_destructor": false}, "stub::function<R(Args...)>::expectation::with(WithArgs&&...)": {"type": "function", "scope": "stub::function< R(Args...)>::expectation", "name": "with", "return": {"type": "expectation &", "description": [{"type": "text", "content": "The expectation itself, which allows chaining function calls"}], "link": "stub::function<R(Args...)>::expectation::expectation(constfunction&)"}, "signature": "with(WithArgs &&... args)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Calling with(...) will add a set of arguments we expect to see. with(...) can be called multiple times in a row if we expect multiple function calls to the function object."}, {"type": "text", "content": "As an example:"}, {"type": "code", "content": "stub::function<void(uint32_t,uint32_t)> function;\nfunction(3,1);\nfunction(4,2);\n\nassert(function.expect_calls()\n           .with(3,1).with(4,2));\n", "is_block": true}], "parameters": [{"type": "WithArgs &&...", "link": null, "name": "args", "description": [{"type": "text", "content": "The arguments for a function call"}]}], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::expectation::to_bool()const": {"type": "function", "scope": "stub::function< R(Args...)>::expectation", "name": "to_bool", "return": {"type": "bool", "description": [{"type": "text", "content": "True if the expectation matches the call, otherwise false"}], "link": null}, "signature": "to_bool() const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Convert the expectation to a boolean value either true of false depending on whether the expectations match the actual call."}, {"type": "text", "content": "The first argument passed to the predicate function is the actual call arguments and the second is the expectation."}], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::expectation::operatorbool()const": {"type": "function", "scope": "stub::function< R(Args...)>::expectation", "name": "operator bool", "return": {"type": "", "description": [{"type": "text", "content": "True if the expectation matches the function, otherwise false"}], "link": null}, "signature": "operator bool() const", "is_const": true, "is_static": false, "is_explicit": true, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Use the to_bool member function when casting this expectation to a boolean value."}], "parameters": [], "is_constructor": true, "is_destructor": false}, "stub::function< R(Args...)>::expectation": {"type": "struct", "name": "expectation", "location": {"file": "stub/function.hpp", "line-start": 75, "line-stop": 160}, "scope": "stub::function< R(Args...)>", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Represent a expectation of how the function object has been invoked. Using the API it is possible to setup how we expect the function object looks like. The expectation converts to bool allowing the user to detect whether the expectation was correct."}], "members": ["stub::function<R(Args...)>::expectation::expectation(constfunction&)", "stub::function<R(Args...)>::expectation::operatorbool()const", "stub::function<R(Args...)>::expectation::to_bool()const", "stub::function<R(Args...)>::expectation::with(WithArgs&&...)"], "access": "public"}, "stub::function": {"type": "class", "name": "function", "location": {"file": "stub/function.hpp", "line-start": 20, "line-stop": -1}, "scope": "stub", "briefdescription": [{"type": "text", "content": "Default function."}], "detaileddescription": [], "members": [], "access": "public"}, "stub::function<R(Args...)>::operator()(Args...)const": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "operator()", "return": {"type": "R", "description": [{"type": "text", "content": "The return value generated by the"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}], "link": null}, "signature": "operator()(Args... args) const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "The call operator to \"simulate\" performing a function call."}], "parameters": [{"type": "Args...", "link": null, "name": "args", "description": [{"type": "text", "content": "The arguments that should be stored"}]}], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::set_return(Returns&&...)": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "set_return", "return": {"type": "return_handler< R > &", "description": [], "link": "stub::return_handler"}, "signature": "set_return(Returns &&... return_value)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "Returns &&...", "link": null, "name": "return_value", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::calls()const": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "calls", "return": {"type": "uint32_t", "description": [{"type": "text", "content": "The number of times the call operator has been invoked"}], "link": null}, "signature": "calls() const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::no_calls()const": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "no_calls", "return": {"type": "bool", "description": [{"type": "text", "content": "True if no calls have been made otherwise false"}], "link": null}, "signature": "no_calls() const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::call_arguments(uint32_t)const": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "call_arguments", "return": {"type": "const arguments< Args... > &", "description": [{"type": "text", "content": "The arguments passed to the n'th call"}], "link": null}, "signature": "call_arguments(uint32_t index) const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "uint32_t", "link": null, "name": "index", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::expect_calls()const": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "expect_calls", "return": {"type": "expectation", "description": [{"type": "text", "content": "An expectation object"}], "link": null}, "signature": "expect_calls() const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Used when we want to check whether the function object is in a certain state. See examples usage in the expectation struct member functions."}], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::clear()": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "clear", "return": {"type": "void", "description": [], "link": null}, "signature": "clear()", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Removes all calls from the function object and reset the return handler."}], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::clear_calls()": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "clear_calls", "return": {"type": "void", "description": [], "link": null}, "signature": "clear_calls()", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Clear the calls."}], "detaileddescription": [], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::function<R(Args...)>::print(std::ostream&)const": {"type": "function", "scope": "stub::function< R(Args...)>", "name": "print", "return": {"type": "void", "description": [], "link": null}, "signature": "print(std::ostream &out) const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Prints the status of the function object to the std::ostream."}, {"type": "text", "content": "Example (using the output operator):"}, {"type": "text", "content": "stub::function<void(uint32_t)> my_func;"}, {"type": "text", "content": "my_func(4U); my_func(5U);"}, {"type": "text", "content": "// Print the current status of the function object, std::cout << my_func << std::endl;"}], "parameters": [{"type": "std::ostream &", "link": null, "name": "out", "description": [{"type": "text", "content": "The ostream where the"}, {"type": "text", "content": "stub::function", "link": "stub::function"}, {"type": "text", "content": "status should be"}]}], "is_constructor": false, "is_destructor": false}, "stub::function< R(Args...)>": {"type": "class", "name": "function< R(Args...)>", "location": {"file": "stub/function.hpp", "line-start": 67, "line-stop": 258}, "scope": "stub", "briefdescription": [{"type": "text", "content": "The function object act like a \"sink\" for function calls i.e. we can define a function object to accept any type of function call and it will simply store the arguments for later inspection."}], "detaileddescription": [{"type": "text", "content": "The typical use-case for the function object is when testing that some code invokes a specific set of functions with a specific set of arguments."}, {"type": "text", "content": "Example:"}, {"type": "text", "content": "stub::function<void(uint32_t)> some_function;"}, {"type": "text", "content": "The above function takes an uint32_t and returns nothing, lets invoke it:"}, {"type": "code", "content": "some_function(3);\nsome_function(4);\n", "is_block": true}, {"type": "text", "content": "Now we may check how the function was called:"}, {"type": "code", "content": "bool called_once = some_function.expect_calls().with(3U);\nassert(called_once == false);\n\nbool called_with = some_function.expect_calls().with(4U);\nassert(called_with == true);\n", "is_block": true}, {"type": "text", "content": "We can also define a function which returns a value:"}, {"type": "code", "content": "stub::function<bool(uint32_t)> another_function;\n", "is_block": true}, {"type": "text", "content": "Here we have to specify what return value we expect:"}, {"type": "code", "content": "another_function.set_return(true);\n\nbool a = another_function(23);\nbool b = another_function(13);\n\nassert(a == true);\nassert(b == true);\n", "is_block": true}, {"type": "text", "content": "For more information on the options for return values see the"}, {"type": "text", "content": "return_handler.hpp", "link": "return__handler_8hpp_source"}], "members": ["stub::function< R(Args...)>::expectation", "stub::function<R(Args...)>::call_arguments(uint32_t)const", "stub::function<R(Args...)>::calls()const", "stub::function<R(Args...)>::clear()", "stub::function<R(Args...)>::clear_calls()", "stub::function<R(Args...)>::expect_calls()const", "stub::function<R(Args...)>::no_calls()const", "stub::function<R(Args...)>::operator()(Args...)const", "stub::function<R(Args...)>::print(std::ostream&)const", "stub::function<R(Args...)>::set_return(Returns&&...)"], "access": "public"}, "stub::ignore": {"type": "struct", "name": "ignore", "location": {"file": "stub/ignore.hpp", "line-start": 22, "line-stop": 22}, "scope": "stub", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "An object used to ignore values of specific arguments when comparing two function calls."}, {"type": "text", "content": "Example:"}, {"type": "text", "content": "stub::function<void(uint32_t, bool)> foo;"}, {"type": "text", "content": "foo(3U, true);"}, {"type": "text", "content": "assert(fool.expect_calls() .with(3U, stub::ignore()));"}], "members": [], "access": "public"}, "stub::compare_call::implementation::implementation(WithArgs&&...)": {"type": "function", "scope": "stub::compare_call::implementation", "name": "implementation", "return": {"type": "", "description": [], "link": null}, "signature": "implementation(WithArgs &&... expected)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "WithArgs &&...", "link": null, "name": "expected", "description": ""}], "is_constructor": true, "is_destructor": false}, "stub::compare_call::implementation::compare(constarguments<Args...>&)const": {"type": "function", "scope": "stub::compare_call::implementation", "name": "compare", "return": {"type": "bool", "description": [], "link": null}, "signature": "compare(const arguments< Args... > &actual) const override", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "const arguments< Args... > &", "link": null, "name": "actual", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_call::implementation": {"type": "struct", "name": "implementation", "location": {"file": "stub/compare_call.hpp", "line-start": 96, "line-stop": 109}, "scope": "stub::compare_call", "briefdescription": [], "detaileddescription": [], "members": ["stub::compare_call::implementation::compare(constarguments<Args...>&)const", "stub::compare_call::implementation::implementation(WithArgs&&...)"], "access": "private"}, "stub::compare_call::interface::compare(constarguments<Args...>&)const": {"type": "function", "scope": "stub::compare_call::interface", "name": "compare", "return": {"type": "bool", "description": [], "link": null}, "signature": "compare(const arguments< Args... > &value) const =0", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": false, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [{"type": "const arguments< Args... > &", "link": null, "name": "value", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_call::interface::~interface()": {"type": "function", "scope": "stub::compare_call::interface", "name": "~interface", "return": {"type": "", "description": [], "link": null}, "signature": "~interface()", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": true, "access": "public", "briefdescription": [], "detaileddescription": [], "parameters": [], "is_constructor": false, "is_destructor": true}, "stub::compare_call::interface": {"type": "struct", "name": "interface", "location": {"file": "stub/compare_call.hpp", "line-start": 87, "line-stop": 92}, "scope": "stub::compare_call", "briefdescription": [{"type": "text", "content": "Interface used in the type erasure."}], "detaileddescription": [], "members": ["stub::compare_call::interface::compare(constarguments<Args...>&)const", "stub::compare_call::interface::~interface()"], "access": "private"}, "stub::not_nullptr": {"type": "struct", "name": "not_nullptr", "location": {"file": "stub/not_nullptr.hpp", "line-start": 23, "line-stop": 23}, "scope": "stub", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "An object used to check if a value is not a null pointer, when comparing two function calls."}, {"type": "text", "content": "Example:"}, {"type": "text", "content": "stub::function<void(uint32_t, uint8_t*)> foo;"}, {"type": "text", "content": "std::vector<uint8_t> buffer(10); foo(3U, buffer.data());"}, {"type": "text", "content": "assert(fool.expect_calls() .with(3U, stub::not_nullptr()));"}], "members": [], "access": "public"}, "stub::return_handler::return_type": {"type": "using", "scope": "stub::return_handler", "location": {"file": "stub/return_handler.hpp", "line-start": 92, "line-stop": -1}, "name": "return_type", "briefdescription": [{"type": "text", "content": "Get the unqualified version of return type."}], "detaileddescription": [], "access": "public", "identifier": {"type": "typename unqualified_type< R >::type", "link": null}}, "stub::return_handler::return_handler()": {"type": "function", "scope": "stub::return_handler", "name": "return_handler", "return": {"type": "", "description": [], "link": null}, "signature": "return_handler()", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Constructor."}], "detaileddescription": [], "parameters": [], "is_constructor": true, "is_destructor": false}, "stub::return_handler::set_return(Args&&...)": {"type": "function", "scope": "stub::return_handler", "name": "set_return", "return": {"type": "return_handler &", "description": [{"type": "text", "content": "Reference to the return handler, this allows the caller to perform additional customization to the return handler such as turn on or off repeat."}], "link": "stub::return_handler"}, "signature": "set_return(Args &&... values)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Initializes the"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}, {"type": "text", "content": "with the return values to use. Calling this function will also reset the"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}, {"type": "text", "content": "state. So any previously specified returns values will be removed etc."}], "parameters": [{"type": "Args &&...", "link": null, "name": "values", "description": [{"type": "text", "content": "The list of return values to use"}]}], "is_constructor": false, "is_destructor": false}, "stub::return_handler::no_repeat()": {"type": "function", "scope": "stub::return_handler", "name": "no_repeat", "return": {"type": "void", "description": [], "link": null}, "signature": "no_repeat()", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Set repeat off. This means that no values will be repeated the user has to specify exactly the number of values that should be return otherwise an assert will be triggered."}], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::return_handler::operator()()const": {"type": "function", "scope": "stub::return_handler", "name": "operator()", "return": {"type": "R", "description": [{"type": "text", "content": "The generated return value"}], "link": null}, "signature": "operator()() const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "The call operator which will generate a return value."}], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::return_handler::add_return(constreturn_type&)": {"type": "function", "scope": "stub::return_handler", "name": "add_return", "return": {"type": "void", "description": [], "link": null}, "signature": "add_return(const return_type &value)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "private", "briefdescription": [{"type": "text", "content": "Overload that adds a return value."}], "detaileddescription": [], "parameters": [{"type": "const return_type &", "link": "stub::return_handler::return_type", "name": "value", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::return_handler::add_return(constreturn_type&,Args&&...)": {"type": "function", "scope": "stub::return_handler", "name": "add_return", "return": {"type": "void", "description": [], "link": null}, "signature": "add_return(const return_type &value, Args &&... more)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "private", "briefdescription": [{"type": "text", "content": "Add a number of return values."}], "detaileddescription": [], "parameters": [{"type": "const return_type &", "link": "stub::return_handler::return_type", "name": "value", "description": ""}, {"type": "Args &&...", "link": null, "name": "more", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::return_handler": {"type": "class", "name": "return_handler", "location": {"file": "stub/return_handler.hpp", "line-start": 87, "line-stop": 188}, "scope": "stub", "briefdescription": [{"type": "text", "content": "The"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}, {"type": "text", "content": "is a helper object that is used e.g. in the function object to control which return values should be generated when called."}], "detaileddescription": [{"type": "text", "content": "The"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}, {"type": "text", "content": "provides the call operator() and when invoked it will return the specified return value. The type R will be the return value."}, {"type": "text", "content": "Example:"}, {"type": "text", "content": "return_handler<uint32_t> v; v.set_return(4U);"}, {"type": "text", "content": "uint32_t a = v(); assert(a == 4U);"}, {"type": "text", "content": "uint32_t b = v(); assert(b == 4U);"}, {"type": "text", "content": "uint32_t c = v(); assert(c != 3U); assert(c == 4U);"}, {"type": "text", "content": "Or alternatively set multiple return values:"}, {"type": "text", "content": "return_handler<uint32_t> v; v.set_return({4U,3U});"}, {"type": "text", "content": "uint32_t a = v(); assert(a == 4U);"}, {"type": "text", "content": "uint32_t b = v(); assert(b == 3U);"}, {"type": "text", "content": "uint32_t c = v(); assert(c == 4U);"}, {"type": "text", "content": "uint32_t d = v(); assert(d != 4U); assert(d == 3U);"}, {"type": "text", "content": "The default behavior is to repeat the specified return values i.e.:"}, {"type": "text", "content": "return_handler<uint32_t> v; v.set_return(3U);"}, {"type": "text", "content": "uint32_t a = v(); uint32_t b = v(); uint32_t c = v();"}, {"type": "text", "content": "assert(a == 3U && b == 3U && c == 3U);"}, {"type": "text", "content": "This behavior can be change by calling"}, {"type": "text", "content": "no_repeat()", "link": "stub::return_handler::no_repeat()"}, {"type": "text", "content": "in which case the"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}, {"type": "text", "content": "can only be invoked once per return value specified:"}, {"type": "text", "content": "return_handler<uint32_t> v; v.set_return(1U)."}, {"type": "text", "content": "no_repeat()", "link": "stub::return_handler::no_repeat()"}, {"type": "text", "content": ";"}, {"type": "text", "content": "uint32_t a = v(); uint32_t b = v(); // <-"}, {"type": "text", "content": "Crash"}, {"type": "text", "content": "return_handler<uint32_t> v; v.set_return({1U,2U,3U})."}, {"type": "text", "content": "no_repeat()", "link": "stub::return_handler::no_repeat()"}, {"type": "text", "content": ";"}, {"type": "text", "content": "uint32_t a = v(); uint32_t b = v(); uint32_t c = v(); uint32_t d = v(); // <-"}, {"type": "text", "content": "Crash"}], "members": ["stub::return_handler::add_return(constreturn_type&)", "stub::return_handler::add_return(constreturn_type&,Args&&...)", "stub::return_handler::no_repeat()", "stub::return_handler::operator()()const", "stub::return_handler::return_handler()", "stub::return_handler::return_type", "stub::return_handler::set_return(Args&&...)"], "access": "public"}, "stub::return_handler<void>::operator()()const": {"type": "function", "scope": "stub::return_handler< void >", "name": "operator()", "return": {"type": "void", "description": [], "link": null}, "signature": "operator()() const", "is_const": true, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Empty call operator."}], "detaileddescription": [], "parameters": [], "is_constructor": false, "is_destructor": false}, "stub::return_handler< void >": {"type": "class", "name": "return_handler< void >", "location": {"file": "stub/return_handler.hpp", "line-start": 195, "line-stop": 202}, "scope": "stub", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Specialization for the case of a void function i.e. no return value. We expect no calls to this"}, {"type": "text", "content": "return_handler", "link": "stub::return_handler"}, {"type": "text", "content": "the call operator is only there to allow the code to compile when e.g. the function class instantiates a return handler."}], "members": ["stub::return_handler<void>::operator()()const"], "access": "public"}, "stub::compare_argument(T,U)": {"type": "function", "scope": "stub", "name": "compare_argument", "return": {"type": "bool", "description": [], "link": null}, "signature": "compare_argument(T a, U b)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Compares two arguments of same type."}], "detaileddescription": [], "parameters": [{"type": "T", "link": null, "name": "a", "description": ""}, {"type": "U", "link": null, "name": "b", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_argument(T,ignore)": {"type": "function", "scope": "stub", "name": "compare_argument", "return": {"type": "bool", "description": [], "link": null}, "signature": "compare_argument(T a, ignore)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Compare function where the second argument is ignore - this always compares true"}], "parameters": [{"type": "T", "link": null, "name": "a", "description": ""}, {"type": "ignore", "link": "stub::ignore", "name": null, "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_argument(T,not_nullptr)": {"type": "function", "scope": "stub", "name": "compare_argument", "return": {"type": "bool", "description": [], "link": null}, "signature": "compare_argument(T a, not_nullptr)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Compare function where the second argument is"}, {"type": "text", "content": "not_nullptr", "link": "stub::not_nullptr"}, {"type": "text", "content": "- this evaluates to true if the first argument is anything but nullptr"}], "parameters": [{"type": "T", "link": null, "name": "a", "description": ""}, {"type": "not_nullptr", "link": "stub::not_nullptr", "name": null, "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_argument(T,compare<Compare>)": {"type": "function", "scope": "stub", "name": "compare_argument", "return": {"type": "bool", "description": [], "link": null}, "signature": "compare_argument(T a, compare< Compare > t)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [{"type": "text", "content": "Compare argument using custom comparison functor."}], "detaileddescription": [], "parameters": [{"type": "T", "link": null, "name": "a", "description": ""}, {"type": "compare< Compare >", "link": "stub::compare", "name": "t", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::compare_arguments(conststd::tuple<Args...>&,conststd::tuple<WithArgs...>&)": {"type": "function", "scope": "stub", "name": "compare_arguments", "return": {"type": "bool", "description": [{"type": "text", "content": "When the two tuples are empty they compare equal so we return true"}], "link": null}, "signature": "compare_arguments(const std::tuple< Args... > &actual, const std::tuple< WithArgs... > &with)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Specialization chosen for empty tuples or when Index reaches the sizeof the tuple (i.e. the number of values in the tuple), see description below."}, {"type": "text", "content": "Compare the content of two tuples."}, {"type": "text", "content": "The two functions compare_arguments use SFINAE (Substitution Failure Is Not An Error) to select which overload to call."}, {"type": "text", "content": "The overloading works like this:"}, {"type": "list", "ordered": true, "items": [[{"type": "text", "content": "If compare_arguments is called with an empty tuple then the empty overload will be chosen."}], [{"type": "text", "content": "If compare_arguments is called with a non-empty tuple the Index!=LastIndex is true and the overload calling compare_arugment(...) will be called. This will then recursively call compare_arguments incrementing the Index. A some point Index==LastIndex and the empty overload gets chosen and we are done."}]]}, {"type": "text", "content": "Note that initially this was implemented using a simpler technique similar to here:"}, {"type": "text", "content": "but this did not work on with Microsoft Visual Studio 2013 so it was implemented using the std::integral_constant technique instead."}], "parameters": [{"type": "const std::tuple< Args... > &", "link": null, "name": "actual", "description": ""}, {"type": "const std::tuple< WithArgs... > &", "link": null, "name": "with", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::operator<<(std::ostream&,constfunction<T>&)": {"type": "function", "scope": "stub", "name": "operator<<", "return": {"type": "std::ostream &", "description": [{"type": "text", "content": "The ostream operator."}], "link": null}, "signature": "operator<<(std::ostream &out, const function< T > &function)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Output operator for printing function objects, see more info in stub::function::print(std::ostream&)."}], "parameters": [{"type": "std::ostream &", "link": null, "name": "out", "description": [{"type": "text", "content": "The output stream where the state of the function object will be printed."}]}, {"type": "const function< T > &", "link": "stub::function", "name": "function", "description": [{"type": "text", "content": "The function object we want to print"}]}], "is_constructor": false, "is_destructor": false}, "stub::make_compare(C)": {"type": "function", "scope": "stub", "name": "make_compare", "return": {"type": "compare< C >", "description": [], "link": "stub::compare"}, "signature": "make_compare(C c)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": false, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Small helper function for creating compare objects."}, {"type": "text", "content": "Example:"}, {"type": "text", "content": "// Build a comparison function from a lambda auto compare = stub::make_compare([](uint32_t v)->bool { return v == 1U}; );"}, {"type": "text", "content": "assert(compare(1U) == true); assert(compare(2U) == false);"}], "parameters": [{"type": "C", "link": null, "name": "c", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::print_argument(std::ostream&,uint32_t,T)": {"type": "function", "scope": "stub", "name": "print_argument", "return": {"type": "void", "description": [], "link": null}, "signature": "print_argument(std::ostream &out, uint32_t index, T value)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Default printer - just use the std::ostream operator<< to output the values to the stream."}], "parameters": [{"type": "std::ostream &", "link": null, "name": "out", "description": ""}, {"type": "uint32_t", "link": null, "name": "index", "description": ""}, {"type": "T", "link": null, "name": "value", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::print_argument(std::ostream&,uint32_t,T*)": {"type": "function", "scope": "stub", "name": "print_argument", "return": {"type": "void", "description": [], "link": null}, "signature": "print_argument(std::ostream &out, uint32_t index, T *value)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Overload of the default printer function for pointer types."}, {"type": "text", "content": "The reason we overload for pointers is that we cannot rely on the default std::ostream operator<< for printing pointers. std::ostream operator<< is overloaded for e.g. char* (and on most platforms also uint8_t*) to try to print it as a zero-terminated string."}, {"type": "text", "content": "However, in many applications dealing with binary data i.e. uint8_t pointers are not to strings but to actual binary data. In these cases trying to print the data as a zero-terminated string leads to all sorts of out-of-bounds memory access."}], "parameters": [{"type": "std::ostream &", "link": null, "name": "out", "description": ""}, {"type": "uint32_t", "link": null, "name": "index", "description": ""}, {"type": "T *", "link": null, "name": "value", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub::print_arguments(std::ostream&,conststd::tuple<Args...>&)": {"type": "function", "scope": "stub", "name": "print_arguments", "return": {"type": "void", "description": [], "link": null}, "signature": "print_arguments(std::ostream &out, const std::tuple< Args... > &t)", "is_const": false, "is_static": false, "is_explicit": false, "is_inline": true, "is_virtual": false, "access": "public", "briefdescription": [], "detaileddescription": [{"type": "text", "content": "Specialization chosen for empty tuples or when Index reaches the sizeof the tuple (i.e. the number of values in the tuple), see description below."}, {"type": "text", "content": "Prints the content of a tuple to the specified std::ostream."}, {"type": "text", "content": "The two functions print_arguments use SFINAE (Substitution Failure Is Not An Error) to select which overload to call."}, {"type": "text", "content": "The overloading works like this:"}, {"type": "list", "ordered": true, "items": [[{"type": "text", "content": "If print_arguments is called with an empty tuple then the empty overload will be chosen."}], [{"type": "text", "content": "If print_argument is called with a non-empty tuple the Index!=LastIndex is true and the overload writing to the std::ostream will be called. This will then recursively call print_arguments incrementing the Index. A some point Index==LastIndex and the empty overload gets chosen and we are done."}]]}, {"type": "text", "content": "Note that initially this was implemented using a simpler technique similar to here:"}, {"type": "text", "content": "but this did not work on with Microsoft Visual Studio 2013 so it was implemented using the std::integral_constant technique instead."}], "parameters": [{"type": "std::ostream &", "link": null, "name": "out", "description": ""}, {"type": "const std::tuple< Args... > &", "link": null, "name": "t", "description": ""}], "is_constructor": false, "is_destructor": false}, "stub": {"type": "namespace", "name": "stub", "scope": "", "briefdescription": [], "detaileddescription": [], "members": ["stub::function", "stub::function< R(Args...)>", "stub::return_handler", "stub::return_handler< void >", "stub::compare", "stub::compare_call", "stub::ignore", "stub::not_nullptr", "stub::compare_argument(T,U)", "stub::compare_argument(T,compare<Compare>)", "stub::compare_argument(T,ignore)", "stub::compare_argument(T,not_nullptr)", "stub::compare_arguments(conststd::tuple<Args...>&,conststd::tuple<WithArgs...>&)", "stub::make_compare(C)", "stub::operator<<(std::ostream&,constfunction<T>&)", "stub::print_argument(std::ostream&,uint32_t,T)", "stub::print_argument(std::ostream&,uint32_t,T*)", "stub::print_arguments(std::ostream&,conststd::tuple<Args...>&)"]}}