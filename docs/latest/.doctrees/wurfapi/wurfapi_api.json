{"stub::compare_call::implementation::implementation(WithArgs&&...)": {"is_const": false, "detaileddescription": "", "return_type": "", "is_static": false, "name": "implementation", "parameters": [{"type": "WithArgs &&...", "name": "expected"}], "access": "public", "location": {"line": 98, "file": "stub/compare_call.hpp"}, "briefdescription": "", "scope": "stub::compare_call::implementation", "type": "function"}, "stub::compare_call::compare_call(class...,WithArgs&&...)": {"is_const": false, "detaileddescription": "", "return_type": "", "is_static": false, "name": "compare_call", "parameters": [{"type": "class...", "name": "WithArgs"}, {"type": "WithArgs &&...", "name": "expected"}], "access": "public", "location": {"line": 67, "file": "stub/compare_call.hpp"}, "briefdescription": "Construct a new call comparison.", "scope": "stub::compare_call", "type": "function"}, "stub::function<R(Args...)>::operator()(Args...)const": {"is_const": true, "detaileddescription": "The call operator to \"simulate\" performing a function call.\nargs\nThe arguments that should be stored\nThe return value generated by the\nreturn_handler", "return_type": "R", "is_static": false, "name": "operator()", "parameters": [{"type": "Args...", "name": "args"}], "access": "public", "location": {"line": 166, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::not_nullptr": {"name": "not_nullptr", "members": [], "detaileddescription": "An object used to check if a value is not a null pointer, when comparing two function calls.\nExample:\nstub::function<void(uint32_t, uint8_t*)> foo;\nstd::vector<uint8_t> buffer(10); foo(3U, buffer.data());\nassert(fool.expect_calls() .with(3U, stub::not_nullptr()));", "briefdescription": "", "scope": "stub", "type": "struct", "location": {"line": 23, "file": "stub/not_nullptr.hpp"}}, "stub::function<R(Args...)>::no_calls()const": {"is_const": true, "detaileddescription": "True if no calls have been made otherwise false", "return_type": "bool", "is_static": false, "name": "no_calls", "parameters": [], "access": "public", "location": {"line": 187, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::compare_call::interface::compare(constarguments<Args...>&)const": {"is_const": true, "detaileddescription": "", "return_type": "bool", "is_static": false, "name": "compare", "parameters": [{"type": "const arguments< Args... > &", "name": "value"}], "access": "public", "location": {"line": 89, "file": "stub/compare_call.hpp"}, "briefdescription": "", "scope": "stub::compare_call::interface", "type": "function"}, "stub::function<R(Args...)>::calls()const": {"is_const": true, "detaileddescription": "The number of times the call operator has been invoked", "return_type": "uint32_t", "is_static": false, "name": "calls", "parameters": [], "access": "public", "location": {"line": 181, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::function<R(Args...)>::print(std::ostream&)const": {"is_const": true, "detaileddescription": "Prints the status of the function object to the std::ostream.\nExample (using the output operator):\nstub::function<void(uint32_t)> my_func;\nmy_func(4U); my_func(5U);\n// Print the current status of the function object, std::cout << my_func << std::endl;\nout\nThe ostream where the\nstub::function\nstatus should be", "return_type": "void", "is_static": false, "name": "print", "parameters": [{"type": "std::ostream &", "name": "out"}], "access": "public", "location": {"line": 236, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::function<R(Args...)>::call_arguments(uint32_t)const": {"is_const": true, "detaileddescription": "The arguments passed to the n'th call", "return_type": "const arguments< Args... > &", "is_static": false, "name": "call_arguments", "parameters": [{"type": "uint32_t", "name": "index"}], "access": "public", "location": {"line": 193, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::function<R(Args...)>::expectation::to_bool()const": {"is_const": true, "detaileddescription": "Convert the expectation to a boolean value either true of false depending on whether the expectations match the actual call.\nThe first argument passed to the predicate function is the actual call arguments and the second is the expectation.\nTrue if the expectation matches the call, otherwise false", "return_type": "bool", "is_static": false, "name": "to_bool", "parameters": [], "access": "public", "location": {"line": 121, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>::expectation", "type": "function"}, "stub::compare": {"name": "compare", "members": ["stub::compare::operator()(classValue,Value)"], "detaileddescription": "An object used to customize comparison of specific arguments when comparing two function calls.\nExample:\nbool test(uint32_t v) { return v == 1U; }\nstub::compare<bool(*)(uint32_t)> compare = { test };\nassert(compare(1U) == true); assert(compare(2U) == false);", "briefdescription": "", "scope": "stub", "type": "struct", "location": {"line": 27, "file": "stub/compare.hpp"}}, "stub::function< R(Args...)>::expectation": {"name": "expectation", "members": ["stub::function<R(Args...)>::expectation::expectation(constfunction&)", "stub::function<R(Args...)>::expectation::with(class...,WithArgs&&...)", "stub::function<R(Args...)>::expectation::to_bool()const", "stub::function<R(Args...)>::expectation::operatorbool()const"], "detaileddescription": "Represent a expectation of how the function object has been invoked. Using the API it is possible to setup how we expect the function object looks like. The expectation converts to bool allowing the user to detect whether the expectation was correct.", "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "struct", "location": {"line": 76, "file": "stub/function.hpp"}}, "stub::return_handler::return_handler()": {"is_const": false, "detaileddescription": "", "return_type": "", "is_static": false, "name": "return_handler", "parameters": [], "access": "public", "location": {"line": 95, "file": "stub/return_handler.hpp"}, "briefdescription": "Constructor.", "scope": "stub::return_handler", "type": "function"}, "stub::function<R(Args...)>::expect_calls()const": {"is_const": true, "detaileddescription": "Used when we want to check whether the function object is in a certain state. See examples usage in the expectation struct member functions.\nAn expectation object", "return_type": "expectation", "is_static": false, "name": "expect_calls", "parameters": [], "access": "public", "location": {"line": 204, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::function<R(Args...)>::set_return(class...,Returns&&...)": {"is_const": false, "detaileddescription": "", "return_type": "return_handler < R > &", "is_static": false, "name": "set_return", "parameters": [{"type": "class...", "name": "Returns"}, {"type": "Returns &&...", "name": "return_value"}], "access": "public", "location": {"line": 174, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::return_handler<void>::operator()()const": {"is_const": true, "detaileddescription": "", "return_type": "void", "is_static": false, "name": "operator()", "parameters": [], "access": "public", "location": {"line": 200, "file": "stub/return_handler.hpp"}, "briefdescription": "Empty call operator.", "scope": "stub::return_handler< void >", "type": "function"}, "stub::compare_call::interface::~interface()": {"is_const": false, "detaileddescription": "", "return_type": "", "is_static": false, "name": "~interface", "parameters": [], "access": "public", "location": {"line": 90, "file": "stub/compare_call.hpp"}, "briefdescription": "", "scope": "stub::compare_call::interface", "type": "function"}, "stub::return_handler::operator()()const": {"is_const": true, "detaileddescription": "The call operator which will generate a return value.\nThe generated return value", "return_type": "R", "is_static": false, "name": "operator()", "parameters": [], "access": "public", "location": {"line": 138, "file": "stub/return_handler.hpp"}, "briefdescription": "", "scope": "stub::return_handler", "type": "function"}, "stub::return_handler::set_return(class...,Args&&...)": {"is_const": false, "detaileddescription": "Todo\nremove this code. or consider a different way to handle this. Make the\nreturn_handler\nnon-copyable\nInitializes the\nreturn_handler\nwith the return values to use. Calling this function will also reset the\nreturn_handler\nstate. So any previously specified returns values will be removed etc.\nvalues\nThe list of return values to use\nReference to the return handler, this allows the caller to perform additional customization to the return handler such as turn on or off repeat.", "return_type": "return_handler &", "is_static": false, "name": "set_return", "parameters": [{"type": "class...", "name": "Args"}, {"type": "Args &&...", "name": "values"}], "access": "public", "location": {"line": 116, "file": "stub/return_handler.hpp"}, "briefdescription": "", "scope": "stub::return_handler", "type": "function"}, "stub::return_handler::add_return(class...,constreturn_type&,Args&&...)": {"is_const": false, "detaileddescription": "", "return_type": "void", "is_static": false, "name": "add_return", "parameters": [{"type": "class...", "name": "Args"}, {"type": "const return_type &", "name": "value"}, {"type": "Args &&...", "name": "more"}], "access": "private", "location": {"line": 167, "file": "stub/return_handler.hpp"}, "briefdescription": "Add a number of return values.", "scope": "stub::return_handler", "type": "function"}, "stub::compare_call::interface": {"name": "interface", "members": ["stub::compare_call::interface::compare(constarguments<Args...>&)const", "stub::compare_call::interface::~interface()"], "detaileddescription": "", "briefdescription": "Interface used in the type erasure.", "scope": "stub::compare_call", "type": "struct", "location": {"line": 88, "file": "stub/compare_call.hpp"}}, "stub::ignore": {"name": "ignore", "members": [], "detaileddescription": "An object used to ignore values of specific arguments when comparing two function calls.\nExample:\nstub::function<void(uint32_t, bool)> foo;\nfoo(3U, true);\nassert(fool.expect_calls() .with(3U, stub::ignore()));", "briefdescription": "", "scope": "stub", "type": "struct", "location": {"line": 22, "file": "stub/ignore.hpp"}}, "stub::function< R(Args...)>": {"name": "function< R(Args...)>", "members": ["stub::function<R(Args...)>::operator()(Args...)const", "stub::function<R(Args...)>::set_return(class...,Returns&&...)", "stub::function<R(Args...)>::calls()const", "stub::function<R(Args...)>::no_calls()const", "stub::function<R(Args...)>::call_arguments(uint32_t)const", "stub::function<R(Args...)>::expect_calls()const", "stub::function<R(Args...)>::clear()", "stub::function<R(Args...)>::clear_calls()", "stub::function<R(Args...)>::print(std::ostream&)const"], "detaileddescription": "The typical use-case for the function object is when testing that some code invokes a specific set of functions with a specific set of arguments.\nExample:\nstub::function<void(uint32_t)> some_function;\nThe above function takes an uint32_t and returns nothing, lets invoke it:\nsome_function(3); some_function(4);\nNow we may check how the function was called:\nbool called_once = some_function.expect_calls().with(3U); assert(called_once == false); bool called_with = some_function.expect_calls().with(4U); assert(called_with == true);\nWe can also define a function which returns a value:\nstub::function<bool(uint32_t)> another_function;\nHere we have to specify what return value we expect:\nanother_function.set_return(true); bool a = another_function(23); bool b = another_function(13); assert(a == true); assert(b == true);\nFor more information on the options for return values see the\nreturn_handler.hpp", "briefdescription": "The function object act like a \"sink\" for function calls i.e. we can define a function object to accept any type of function call and it will simply store the arguments for later inspection.", "scope": "stub", "type": "class", "location": {"line": 67, "file": "stub/function.hpp"}}, "stub::function<R(Args...)>::expectation::operatorbool()const": {"is_const": true, "detaileddescription": "Use the to_bool member function when casting this expectation to a boolean value.\nTrue if the expectation matches the function, otherwise false", "return_type": "", "is_static": false, "name": "operator bool", "parameters": [], "access": "public", "location": {"line": 146, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>::expectation", "type": "function"}, "stub::compare_call": {"name": "compare_call", "members": ["stub::compare_call::compare_call(class...,WithArgs&&...)", "stub::compare_call::compare(constarguments<Args...>&)const"], "detaileddescription": "This stores a tuple of types that is to, at some point, be compared with a different tuple of arguments.\nThe basic usage is as follows:\nauto expectation = std::make_tuple(5, true, 4.0); compare_call<int, bool, double> expect(expectation);\nauto actual = std::make_tuple(4, true, 4.0);\n// Now compare our expectation with the actual values bool result = expect.compare(actual); assert(result == false);\nThe\ncompare_call::compare\n(...) function uses compare_arguments(...) to compare the elements of the two tuples element-wise using compare_argument(...). In the case above the two tuples contain the same types. So every thing is pretty straight-forward.\nHowever, in some cases we want to customize the comparison of two element. This could be that we simply don't care about a specific value or we want to use a user-define comparison function.\nTo support this use-case we allow special values to be used in the comparison tuple. The two tuples can therefore have different types, making the implementation a bit more involved and the reason for the type-erausre implemented in this class.\nLets see how this would work in practice.\n// Notice how we can pass ignore() as the second argument to our // expectation tuple. auto expectation = std::make_tuple(5, ignore(), 4.0); compare_call<int, bool, double> expect(expectation);\nauto actual = std::make_tuple(5, true, 4.0);\n// Now compare our expectation with the actual values bool result = expect.compare(actual); assert(result == true);\nThe reason this works when comparing the two tuples element-wise is that the compare_argument(...) function has an overload that accepts ignore as the second argument. By specializing compare_argument(...) we can extend support for more special values to support custom behaviour.", "briefdescription": "", "scope": "stub", "type": "struct", "location": {"line": 64, "file": "stub/compare_call.hpp"}}, "stub::compare_call::compare(constarguments<Args...>&)const": {"is_const": true, "detaileddescription": "Compare the values of the passed tuple with those of the expectation.", "return_type": "bool", "is_static": false, "name": "compare", "parameters": [{"type": "const arguments< Args... > &", "name": "actual"}], "access": "public", "location": {"line": 78, "file": "stub/compare_call.hpp"}, "briefdescription": "", "scope": "stub::compare_call", "type": "function"}, "stub::compare::operator()(classValue,Value)": {"is_const": false, "detaileddescription": "", "return_type": "bool", "is_static": false, "name": "operator()", "parameters": [{"type": "class Value", "name": ""}, {"type": "Value", "name": "v"}], "access": "public", "location": {"line": 30, "file": "stub/compare.hpp"}, "briefdescription": "Call operator which calls the compare function with the passed value.", "scope": "stub::compare", "type": "function"}, "stub::return_handler::add_return(constreturn_type&)": {"is_const": false, "detaileddescription": "", "return_type": "void", "is_static": false, "name": "add_return", "parameters": [{"type": "const return_type &", "name": "value"}], "access": "private", "location": {"line": 159, "file": "stub/return_handler.hpp"}, "briefdescription": "Overload that adds a return value.", "scope": "stub::return_handler", "type": "function"}, "stub::compare_call::implementation": {"name": "implementation", "members": ["stub::compare_call::implementation::implementation(WithArgs&&...)", "stub::compare_call::implementation::compare(constarguments<Args...>&)const"], "detaileddescription": "", "briefdescription": "", "scope": "stub::compare_call", "type": "struct", "location": {"line": 97, "file": "stub/compare_call.hpp"}}, "stub::function<R(Args...)>::clear()": {"is_const": false, "detaileddescription": "Removes all calls from the function object and reset the return handler.", "return_type": "void", "is_static": false, "name": "clear", "parameters": [], "access": "public", "location": {"line": 211, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::return_handler": {"name": "return_handler", "members": ["stub::return_handler::return_handler()", "stub::return_handler::set_return(class...,Args&&...)", "stub::return_handler::no_repeat()", "stub::return_handler::operator()()const", "stub::return_handler::add_return(constreturn_type&)", "stub::return_handler::add_return(class...,constreturn_type&,Args&&...)"], "detaileddescription": "The\nreturn_handler\nprovides the call operator() and when invoked it will return the specified return value. The type R will be the return value.\nExample:\nreturn_handler<uint32_t> v; v.set_return(4U);\nuint32_t a = v(); assert(a == 4U);\nuint32_t b = v(); assert(b == 4U);\nuint32_t c = v(); assert(c != 3U); assert(c == 4U);\nOr alternatively set multiple return values:\nreturn_handler<uint32_t> v; v.set_return({4U,3U});\nuint32_t a = v(); assert(a == 4U);\nuint32_t b = v(); assert(b == 3U);\nuint32_t c = v(); assert(c == 4U);\nuint32_t d = v(); assert(d != 4U); assert(d == 3U);\nThe default behavior is to repeat the specified return values i.e.:\nreturn_handler<uint32_t> v; v.set_return(3U);\nuint32_t a = v(); uint32_t b = v(); uint32_t c = v();\nassert(a == 3U && b == 3U && c == 3U);\nThis behavior can be change by calling\nno_repeat()\nin which case the\nreturn_handler\ncan only be invoked once per return value specified:\nreturn_handler<uint32_t> v; v.set_return(1U).\nno_repeat()\n;\nuint32_t a = v(); uint32_t b = v(); // <-\nCrash\nreturn_handler<uint32_t> v; v.set_return({1U,2U,3U}).\nno_repeat()\n;\nuint32_t a = v(); uint32_t b = v(); uint32_t c = v(); uint32_t d = v(); // <-\nCrash", "briefdescription": "The\nreturn_handler\nis a helper object that is used e.g. in the function object to control which return values should be generated when called.", "scope": "stub", "type": "class", "location": {"line": 88, "file": "stub/return_handler.hpp"}}, "stub::function<R(Args...)>::expectation::expectation(constfunction&)": {"is_const": false, "detaileddescription": "the_function\nThe function we configuring an expectation for\npredicate\nThe function object used to compare the call arguments", "return_type": "", "is_static": false, "name": "expectation", "parameters": [{"type": "const function &", "name": "the_function"}], "access": "public", "location": {"line": 81, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>::expectation", "type": "function"}, "stub::return_handler::no_repeat()": {"is_const": false, "detaileddescription": "Set repeat off. This means that no values will be repeated the user has to specify exactly the number of values that should be return otherwise an assert will be triggered.\nTodo\nconsider making opposite behavior default.", "return_type": "void", "is_static": false, "name": "no_repeat", "parameters": [], "access": "public", "location": {"line": 131, "file": "stub/return_handler.hpp"}, "briefdescription": "", "scope": "stub::return_handler", "type": "function"}, "stub::function<R(Args...)>::expectation::with(class...,WithArgs&&...)": {"is_const": false, "detaileddescription": "Calling with(...) will add a set of arguments we expect to see. with(...) can be called multiple times in a row if we expect multiple function calls to the function object.\nAs an example:\nstub::function<void(uint32_t,uint32_t)> function; function(3,1); function(4,2); assert(function.expect_calls() .with(3,1).with(4,2));\nargs\nThe arguments for a function call\nThe expectation itself, which allows chaining function calls", "return_type": "expectation &", "is_static": false, "name": "with", "parameters": [{"type": "class...", "name": "WithArgs"}, {"type": "WithArgs &&...", "name": "args"}], "access": "public", "location": {"line": 105, "file": "stub/function.hpp"}, "briefdescription": "", "scope": "stub::function< R(Args...)>::expectation", "type": "function"}, "stub::compare_call::implementation::compare(constarguments<Args...>&)const": {"is_const": true, "detaileddescription": "", "return_type": "bool", "is_static": false, "name": "compare", "parameters": [{"type": "const arguments< Args... > &", "name": "actual"}], "access": "public", "location": {"line": 102, "file": "stub/compare_call.hpp"}, "briefdescription": "", "scope": "stub::compare_call::implementation", "type": "function"}, "stub::return_handler< void >": {"name": "return_handler< void >", "members": ["stub::return_handler<void>::operator()()const"], "detaileddescription": "Specialization for the case of a void function i.e. no return value. We expect no calls to this\nreturn_handler\nthe call operator is only there to allow the code to compile when e.g. the function class instantiates a return handler.", "briefdescription": "", "scope": "stub", "type": "class", "location": {"line": 196, "file": "stub/return_handler.hpp"}}, "stub::function<R(Args...)>::clear_calls()": {"is_const": false, "detaileddescription": "", "return_type": "void", "is_static": false, "name": "clear_calls", "parameters": [], "access": "public", "location": {"line": 218, "file": "stub/function.hpp"}, "briefdescription": "Clear the calls.", "scope": "stub::function< R(Args...)>", "type": "function"}, "stub::function": {"name": "function", "members": [], "detaileddescription": "", "briefdescription": "Default function.", "scope": "stub", "type": "class", "location": {"line": 19, "file": "stub/function.hpp"}}}